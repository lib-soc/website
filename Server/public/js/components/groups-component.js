
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
import { S as SvelteElement, i as init, a as attribute_to_object, b as insert_dev, p as flush, s as safe_not_equal, v as validate_each_argument, d as dispatch_dev, c as validate_slots, o as onMount, e as element, f as space, n as noop, g as add_location, h as set_custom_element_data, j as attr_dev, k as append_dev, l as detach_dev, m as destroy_each, t as text } from './index-3e97afc8.js';
import { groups, addMarkersGroups } from '../../../../../../../../../js/groups.js';
import '../../../../../../../../../js/components/map-component.js';

/* src\groups-component.svelte generated by Svelte v3.52.0 */

const file = "src\\groups-component.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (30:8) {#each groups as group}
function create_each_block(ctx) {
	let div;
	let p0;
	let b0;
	let t1_value = /*group*/ ctx[1].location[0] + "";
	let t1;
	let t2;
	let p1;
	let b1;
	let t4_value = /*group*/ ctx[1].members + "";
	let t4;
	let t5;
	let p2;
	let b2;
	let a;
	let t7_value = /*group*/ ctx[1].contact[1] + "";
	let t7;
	let t8;

	const block = {
		c: function create() {
			div = element("div");
			p0 = element("p");
			b0 = element("b");
			b0.textContent = "Location: ";
			t1 = text(t1_value);
			t2 = space();
			p1 = element("p");
			b1 = element("b");
			b1.textContent = "Members: ";
			t4 = text(t4_value);
			t5 = space();
			p2 = element("p");
			b2 = element("b");
			b2.textContent = "Contact: ";
			a = element("a");
			t7 = text(t7_value);
			t8 = space();
			add_location(b0, file, 31, 19, 2027);
			add_location(p0, file, 31, 16, 2024);
			add_location(b1, file, 32, 19, 2088);
			add_location(p1, file, 32, 16, 2085);
			add_location(b2, file, 33, 19, 2144);
			attr_dev(a, "href", /*group*/ ctx[1].contact[0]);
			attr_dev(a, "target", ";_blank;");
			attr_dev(a, "rel", "noreferrer");
			add_location(a, file, 33, 35, 2160);
			add_location(p2, file, 33, 16, 2141);
			attr_dev(div, "class", "location-info");
			add_location(div, file, 30, 12, 1979);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, p0);
			append_dev(p0, b0);
			append_dev(p0, t1);
			append_dev(div, t2);
			append_dev(div, p1);
			append_dev(p1, b1);
			append_dev(p1, t4);
			append_dev(div, t5);
			append_dev(div, p2);
			append_dev(p2, b2);
			append_dev(p2, a);
			append_dev(a, t7);
			append_dev(div, t8);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(30:8) {#each groups as group}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let h1;
	let t1;
	let p0;
	let t3;
	let p1;
	let t5;
	let h3;
	let t7;
	let map_component;
	let t8;
	let h4;
	let t10;
	let each_value = groups;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			h1 = element("h1");
			h1.textContent = "Groups";
			t1 = space();
			p0 = element("p");
			p0.textContent = "We try to raise awareness among individuals about the detrimental impact of the current politico-economic systems on our collective well-being. Through educational initiatives, community engagement, and critical analysis, we strive to illuminate the structural flaws and inherent inequalities that permeate capitalist societies. By shedding light on these systemic issues, we empower people to question the status quo and envision alternative paths towards a more just and sustainable future.";
			t3 = space();
			p1 = element("p");
			p1.textContent = "However, our mission extends beyond theoretical exploration and ideological discourse. We firmly believe in the power of mutual aid and collective action to alleviate the immediate challenges and hardships faced within a capitalist framework. Through the practice of mutual aid, we actively support one another by sharing resources, knowledge, and skills, thereby fostering a sense of solidarity and resilience. Whether it's organizing community gardens, establishing local food cooperatives, or providing mutual support networks, our aim is to make life under capitalism more bearable and to cultivate pockets of resistance and alternatives within the existing system.";
			t5 = space();
			h3 = element("h3");
			h3.textContent = "Our groups";
			t7 = space();
			map_component = element("map-component");
			t8 = space();
			h4 = element("h4");
			h4.textContent = "Europe";
			t10 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.c = noop;
			add_location(h1, file, 23, 8, 589);
			add_location(p0, file, 24, 8, 614);
			add_location(p1, file, 25, 8, 1123);
			add_location(h3, file, 26, 8, 1809);
			set_custom_element_data(map_component, "id", "map");
			set_custom_element_data(map_component, "callback", /*mapCallbackGroups*/ ctx[0]);
			add_location(map_component, file, 27, 8, 1838);
			add_location(h4, file, 28, 8, 1917);
			attr_dev(div0, "id", "text-container");
			add_location(div0, file, 22, 4, 554);
			attr_dev(div1, "id", "container");
			add_location(div1, file, 20, 0, 467);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, h1);
			append_dev(div0, t1);
			append_dev(div0, p0);
			append_dev(div0, t3);
			append_dev(div0, p1);
			append_dev(div0, t5);
			append_dev(div0, h3);
			append_dev(div0, t7);
			append_dev(div0, map_component);
			append_dev(div0, t8);
			append_dev(div0, h4);
			append_dev(div0, t10);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*groups*/ 0) {
				each_value = groups;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('groups-component', slots, []);

	function mapCallbackGroups(createMap) {
		let map = createMap([51.505, -0.09], 3);
		addMarkersGroups(map);
	}

	onMount(() => {
		
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<groups-component> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		onMount,
		groups,
		addMarkersGroups,
		mapCallbackGroups
	});

	return [mapCallbackGroups];
}

class Groups_component extends SvelteElement {
	constructor(options) {
		super();
		this.shadowRoot.innerHTML = `<style>@import '/css/common.css';h4{margin-bottom:2rem}.location-info p{margin-bottom:0}a{font-size:1.2rem;color:#DD1C1A}#map{--height:30rem;--width:100%;--margin-bottom:3rem}#text-container{max-width:calc(100vw - 4rem);margin:auto}h1{margin-bottom:1rem;font-size:2.5rem;text-align:center}h3{margin-bottom:1rem}#container{margin:auto;max-width:1200px;margin-top:1rem;margin-bottom:4rem}#container>div>p{margin-bottom:1rem}#container p{font-size:1.2rem;text-align:justify}</style>`;

		init(
			this,
			{
				target: this.shadowRoot,
				props: attribute_to_object(this.attributes),
				customElement: true
			},
			instance,
			create_fragment,
			safe_not_equal,
			{ mapCallbackGroups: 0 },
			null
		);

		if (options) {
			if (options.target) {
				insert_dev(options.target, this, options.anchor);
			}

			if (options.props) {
				this.$set(options.props);
				flush();
			}
		}
	}

	static get observedAttributes() {
		return ["mapCallbackGroups"];
	}

	get mapCallbackGroups() {
		return this.$$.ctx[0];
	}

	set mapCallbackGroups(value) {
		throw new Error("<groups-component>: Cannot set read-only property 'mapCallbackGroups'");
	}
}

customElements.define("groups-component", Groups_component);

export { Groups_component as default };
