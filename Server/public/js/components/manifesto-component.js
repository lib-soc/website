
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
import { S as SvelteElement, i as init, a as attribute_to_object, b as insert_dev, s as safe_not_equal, d as dispatch_dev, c as validate_slots, o as onMount, q as globals, v as validate_each_argument, e as element, n as noop, j as attr_dev, g as add_location, k as append_dev, l as detach_dev, D as empty, m as destroy_each, f as space, t as text, H as HtmlTag } from './index-3e97afc8.js';
import { getData } from '../../../../../../../../../js/libraries/serverTools.js';

/* src\manifesto-component.svelte generated by Svelte v3.52.0 */

const { Object: Object_1 } = globals;
const file = "src\\manifesto-component.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (54:16) {#if line!==""}
function create_if_block(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (typeof (/*line*/ ctx[3] === 'object') && Object.keys(/*line*/ ctx[3])[0] == "ul") return create_if_block_1;
		if (typeof (/*line*/ ctx[3] === 'object') && Object.keys(/*line*/ ctx[3])[0] == "ol") return create_if_block_2;
		if (/*line*/ ctx[3].slice(0, 3) == "###") return create_if_block_3;
		if (/*line*/ ctx[3].slice(0, 2) == "##") return create_if_block_4;
		if (/*line*/ ctx[3][0] == "#") return create_if_block_5;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if_block.p(ctx, dirty);
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(54:16) {#if line!==\\\"\\\"}",
		ctx
	});

	return block;
}

// (75:20) {:else}
function create_else_block(ctx) {
	let p;
	let html_tag;
	let raw_value = /*line*/ ctx[3] + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			html_tag = new HtmlTag(false);
			t = space();
			html_tag.a = t;
			attr_dev(p, "class", "margin-end");
			add_location(p, file, 75, 24, 2558);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			html_tag.m(raw_value, p);
			append_dev(p, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(75:20) {:else}",
		ctx
	});

	return block;
}

// (73:43) 
function create_if_block_5(ctx) {
	let h1;
	let raw_value = /*line*/ ctx[3].slice(2, /*line*/ ctx[3].length) + "";

	const block = {
		c: function create() {
			h1 = element("h1");
			add_location(h1, file, 73, 24, 2461);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			h1.innerHTML = raw_value;
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(73:43) ",
		ctx
	});

	return block;
}

// (71:52) 
function create_if_block_4(ctx) {
	let h2;
	let raw_value = /*line*/ ctx[3].slice(3, /*line*/ ctx[3].length) + "";

	const block = {
		c: function create() {
			h2 = element("h2");
			add_location(h2, file, 71, 24, 2348);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			h2.innerHTML = raw_value;
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(71:52) ",
		ctx
	});

	return block;
}

// (69:53) 
function create_if_block_3(ctx) {
	let h3;
	let raw_value = /*line*/ ctx[3].slice(4, /*line*/ ctx[3].length) + "";

	const block = {
		c: function create() {
			h3 = element("h3");
			add_location(h3, file, 69, 24, 2226);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h3, anchor);
			h3.innerHTML = raw_value;
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(69:53) ",
		ctx
	});

	return block;
}

// (61:89) 
function create_if_block_2(ctx) {
	let ol;
	let t;
	let each_value_2 = /*line*/ ctx[3].ol;
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const block = {
		c: function create() {
			ol = element("ol");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			add_location(ol, file, 61, 24, 1891);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ol, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ol, null);
			}

			append_dev(ol, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*manifesto*/ 2) {
				each_value_2 = /*line*/ ctx[3].ol;
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ol, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ol);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(61:89) ",
		ctx
	});

	return block;
}

// (55:20) {#if typeof (line === 'object') && (Object.keys(line)[0]=="ul")}
function create_if_block_1(ctx) {
	let ul;
	let t;
	let each_value_1 = /*line*/ ctx[3].ul;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			add_location(ul, file, 55, 24, 1598);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append_dev(ul, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*manifesto*/ 2) {
				each_value_1 = /*line*/ ctx[3].ul;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(55:20) {#if typeof (line === 'object') && (Object.keys(line)[0]==\\\"ul\\\")}",
		ctx
	});

	return block;
}

// (63:28) {#each line.ol as line2}
function create_each_block_2(ctx) {
	let li;
	let raw_value = /*line2*/ ctx[6] + "";

	const block = {
		c: function create() {
			li = element("li");
			add_location(li, file, 63, 32, 1983);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			li.innerHTML = raw_value;
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(63:28) {#each line.ol as line2}",
		ctx
	});

	return block;
}

// (57:28) {#each line.ul as line2}
function create_each_block_1(ctx) {
	let li;
	let t_value = /*line2*/ ctx[6] + "";
	let t;

	const block = {
		c: function create() {
			li = element("li");
			t = text(t_value);
			add_location(li, file, 57, 32, 1690);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(57:28) {#each line.ul as line2}",
		ctx
	});

	return block;
}

// (53:12) {#each manifesto as line}
function create_each_block(ctx) {
	let if_block_anchor;
	let if_block = /*line*/ ctx[3] !== "" && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*line*/ ctx[3] !== "") if_block.p(ctx, dirty);
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(53:12) {#each manifesto as line}",
		ctx
	});

	return block;
}

// (52:8) {#key key}
function create_key_block(ctx) {
	let each_1_anchor;
	let each_value = /*manifesto*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*manifesto, Object*/ 2) {
				each_value = /*manifesto*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_key_block.name,
		type: "key",
		source: "(52:8) {#key key}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let previous_key = /*key*/ ctx[0];
	let key_block = create_key_block(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			key_block.c();
			this.c = noop;
			attr_dev(div0, "id", "text-container");
			add_location(div0, file, 50, 4, 1369);
			attr_dev(div1, "id", "container");
			add_location(div1, file, 49, 0, 1343);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			key_block.m(div0, null);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*key*/ 1 && safe_not_equal(previous_key, previous_key = /*key*/ ctx[0])) {
				key_block.d(1);
				key_block = create_key_block(ctx);
				key_block.c();
				key_block.m(div0, null);
			} else {
				key_block.p(ctx, dirty);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			key_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('manifesto-component', slots, []);
	let manifesto = [];
	let key;
	const htmlDelims = ["ul", "ol"];

	getData("/assets/manifesto.txt", function (response) {
		let splitText = response.split(/\r?\n/);

		for (let j = 0; j < splitText.length; j++) {
			let line = splitText[j];
			let delimInd = htmlDelims.map(x => line.includes("<" + x + ">")).findIndex(x => x);

			if (delimInd != -1) {
				let delim = htmlDelims[delimInd];
				let obj = {};
				obj[delim] = [];
				let delimEndTag = "</" + delim + ">";

				while (true) {
					j += 1;
					line = splitText[j];

					if (line.includes(delimEndTag)) {
						manifesto.push(obj);
						break;
					} else {
						obj[delim].push(line);
					}
				}
			} else {
				manifesto.push(line);
			}
		}

		$$invalidate(0, key += 1);
	});

	onMount(() => {
		
	});

	const writable_props = [];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<manifesto-component> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		onMount,
		getData,
		manifesto,
		key,
		htmlDelims
	});

	$$self.$inject_state = $$props => {
		if ('manifesto' in $$props) $$invalidate(1, manifesto = $$props.manifesto);
		if ('key' in $$props) $$invalidate(0, key = $$props.key);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [key, manifesto];
}

class Manifesto_component extends SvelteElement {
	constructor(options) {
		super();
		this.shadowRoot.innerHTML = `<style>@import '/css/common.css';h1{margin-bottom:1rem;font-size:2.5rem;text-align:center}h2{margin-bottom:1rem;text-align:center}h3{margin-bottom:1rem}#text-container{max-width:calc(100vw - 4rem);margin:auto}#container{margin:auto;max-width:1200px;margin-top:1rem;margin-bottom:4rem}#container>div>p{margin-bottom:1rem}#container p{font-size:1.2rem;text-align:justify}</style>`;

		init(
			this,
			{
				target: this.shadowRoot,
				props: attribute_to_object(this.attributes),
				customElement: true
			},
			instance,
			create_fragment,
			safe_not_equal,
			{},
			null
		);

		if (options) {
			if (options.target) {
				insert_dev(options.target, this, options.anchor);
			}
		}
	}
}

customElements.define("manifesto-component", Manifesto_component);

export { Manifesto_component as default };
