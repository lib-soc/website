
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
import { S as SvelteElement, i as init, a as attribute_to_object, b as insert_dev, s as safe_not_equal, d as dispatch_dev, v as validate_slots, w as validate_store, x as component_subscribe, o as onMount, e as globals, y as empty, n as noop, p as detach_dev, q as binding_callbacks, A as validate_each_argument, f as element, k as attr_dev, j as add_location, l as append_dev, B as text, h as space, u as src_url_equal, F as set_style, m as listen_dev, C as set_data_dev, D as destroy_each, H as is_function, I as HtmlTag } from './index-998178c7.js';
import { w as writable } from './index-f9998ce7.js';
import { loadLocaleContent, getData } from '../../../../../../../../../js/libraries/serverTools.js';
import { px2rem } from '../../../../../../../../../js/libraries/miscTools.js';

/* src\manifesto-component.svelte generated by Svelte v3.52.0 */

const { Object: Object_1 } = globals;
const file = "src\\manifesto-component.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	child_ctx[34] = list;
	child_ctx[35] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[36] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[36] = list[i];
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[41] = list[i];
	child_ctx[42] = list;
	child_ctx[43] = i;
	return child_ctx;
}

function get_each_context_4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[44] = list[i];
	child_ctx[45] = list;
	child_ctx[46] = i;
	return child_ctx;
}

// (168:4) {#if $loaded==2}
function create_if_block(ctx) {
	let div1;
	let div0;
	let previous_key = /*key*/ ctx[0];
	let key_block = create_key_block_1(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			key_block.c();
			attr_dev(div0, "id", "text-container");
			add_location(div0, file, 169, 12, 6059);
			attr_dev(div1, "id", "container");
			add_location(div1, file, 168, 8, 6008);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			key_block.m(div0, null);
			/*div1_binding_1*/ ctx[28](div1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*key*/ 1 && safe_not_equal(previous_key, previous_key = /*key*/ ctx[0])) {
				key_block.d(1);
				key_block = create_key_block_1(ctx);
				key_block.c();
				key_block.m(div0, null);
			} else {
				key_block.p(ctx, dirty);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			key_block.d(detaching);
			/*div1_binding_1*/ ctx[28](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(168:4) {#if $loaded==2}",
		ctx
	});

	return block;
}

// (187:32) {:else}
function create_else_block_1(ctx) {
	let div;
	let button;
	let t0_value = /*obj*/ ctx[41].name + "";
	let t0;
	let obj = /*obj*/ ctx[41];
	let t1;
	let mounted;
	let dispose;
	const assign_button = () => /*button_binding_2*/ ctx[21](button, obj);
	const unassign_button = () => /*button_binding_2*/ ctx[21](null, obj);

	function click_handler_2() {
		return /*click_handler_2*/ ctx[22](/*obj*/ ctx[41]);
	}

	const block = {
		c: function create() {
			div = element("div");
			button = element("button");
			t0 = text(t0_value);
			t1 = space();
			attr_dev(button, "class", "level0 heading-button");
			add_location(button, file, 188, 40, 7396);
			attr_dev(div, "class", "heading-button-wrapper");
			add_location(div, file, 187, 36, 7318);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button);
			append_dev(button, t0);
			assign_button();
			append_dev(div, t1);

			if (!mounted) {
				dispose = listen_dev(button, "click", click_handler_2, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (obj !== /*obj*/ ctx[41]) {
				unassign_button();
				obj = /*obj*/ ctx[41];
				assign_button();
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			unassign_button();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(187:32) {:else}",
		ctx
	});

	return block;
}

// (179:32) {#if Array.isArray(obj)}
function create_if_block_8(ctx) {
	let each_1_anchor;
	let each_value_4 = /*obj*/ ctx[41];
	validate_each_argument(each_value_4);
	let each_blocks = [];

	for (let i = 0; i < each_value_4.length; i += 1) {
		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*buttons, contentHeadings, goToChapter*/ 36880) {
				each_value_4 = /*obj*/ ctx[41];
				validate_each_argument(each_value_4);
				let i;

				for (i = 0; i < each_value_4.length; i += 1) {
					const child_ctx = get_each_context_4(ctx, each_value_4, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_4.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(179:32) {#if Array.isArray(obj)}",
		ctx
	});

	return block;
}

// (180:36) {#each obj as obj2}
function create_each_block_4(ctx) {
	let div;
	let button;
	let t0_value = /*obj2*/ ctx[44].name + "";
	let t0;
	let obj2 = /*obj2*/ ctx[44];
	let t1;
	let mounted;
	let dispose;
	const assign_button = () => /*button_binding_1*/ ctx[19](button, obj2);
	const unassign_button = () => /*button_binding_1*/ ctx[19](null, obj2);

	function click_handler_1() {
		return /*click_handler_1*/ ctx[20](/*obj2*/ ctx[44]);
	}

	const block = {
		c: function create() {
			div = element("div");
			button = element("button");
			t0 = text(t0_value);
			t1 = space();
			attr_dev(button, "class", "level1 heading-button");
			add_location(button, file, 181, 40, 6934);
			attr_dev(div, "class", "heading-button-wrapper");
			add_location(div, file, 180, 36, 6856);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button);
			append_dev(button, t0);
			assign_button();
			append_dev(div, t1);

			if (!mounted) {
				dispose = listen_dev(button, "click", click_handler_1, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (obj2 !== /*obj2*/ ctx[44]) {
				unassign_button();
				obj2 = /*obj2*/ ctx[44];
				assign_button();
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			unassign_button();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_4.name,
		type: "each",
		source: "(180:36) {#each obj as obj2}",
		ctx
	});

	return block;
}

// (178:28) {#each contentHeadings as obj}
function create_each_block_3(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (Array.isArray(/*obj*/ ctx[41])) return create_if_block_8;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if_block.p(ctx, dirty);
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3.name,
		type: "each",
		source: "(178:28) {#each contentHeadings as obj}",
		ctx
	});

	return block;
}

// (199:28) {#if line!==""}
function create_if_block_1(ctx) {
	let if_block_anchor;

	function select_block_type_2(ctx, dirty) {
		if (typeof (/*line*/ ctx[33] === 'object') && Object.keys(/*line*/ ctx[33])[0] == "ul") return create_if_block_2;
		if (typeof (/*line*/ ctx[33] === 'object') && Object.keys(/*line*/ ctx[33])[0] == "ol") return create_if_block_3;
		if (typeof (/*line*/ ctx[33] === 'object') && /*line*/ ctx[33].type == "h3") return create_if_block_4;
		if (typeof (/*line*/ ctx[33] === 'object') && /*line*/ ctx[33].type == "h2") return create_if_block_5;
		if (/*line*/ ctx[33][0] == "#") return create_if_block_6;
		return create_else_block;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if_block.p(ctx, dirty);
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(199:28) {#if line!==\\\"\\\"}",
		ctx
	});

	return block;
}

// (224:32) {:else}
function create_else_block(ctx) {
	let p;
	let html_tag;
	let raw_value = /*line*/ ctx[33] + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			html_tag = new HtmlTag(false);
			t = space();
			html_tag.a = t;
			attr_dev(p, "class", "margin-end");
			add_location(p, file, 224, 36, 9794);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			html_tag.m(raw_value, p);
			append_dev(p, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(224:32) {:else}",
		ctx
	});

	return block;
}

// (222:55) 
function create_if_block_6(ctx) {
	let h1;
	let raw_value = /*line*/ ctx[33].slice(2, /*line*/ ctx[33].length) + "";

	const block = {
		c: function create() {
			h1 = element("h1");
			add_location(h1, file, 222, 36, 9673);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			h1.innerHTML = raw_value;
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(222:55) ",
		ctx
	});

	return block;
}

// (218:90) 
function create_if_block_5(ctx) {
	let button;
	let h2;
	let raw_value = /*line*/ ctx[33].line + "";
	let line = /*line*/ ctx[33];
	let t;
	let mounted;
	let dispose;
	const assign_h2 = () => /*h2_binding*/ ctx[26](h2, line);
	const unassign_h2 = () => /*h2_binding*/ ctx[26](null, line);

	const block = {
		c: function create() {
			button = element("button");
			h2 = element("h2");
			t = space();
			attr_dev(h2, "id", /*line*/ ctx[33].id);
			add_location(h2, file, 219, 40, 9455);
			set_style(button, "display", "block");
			set_style(button, "width", "100%");
			add_location(button, file, 218, 36, 9302);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, h2);
			h2.innerHTML = raw_value;
			assign_h2();
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(
					button,
					"click",
					function () {
						if (is_function(/*contentTable*/ ctx[6].scrollIntoView({ block: 'start' }, true))) /*contentTable*/ ctx[6].scrollIntoView({ block: 'start' }, true).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (line !== /*line*/ ctx[33]) {
				unassign_h2();
				line = /*line*/ ctx[33];
				assign_h2();
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			unassign_h2();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(218:90) ",
		ctx
	});

	return block;
}

// (214:90) 
function create_if_block_4(ctx) {
	let button;
	let h3;
	let raw_value = /*line*/ ctx[33].line + "";
	let line = /*line*/ ctx[33];
	let t;
	let mounted;
	let dispose;
	const assign_h3 = () => /*h3_binding*/ ctx[25](h3, line);
	const unassign_h3 = () => /*h3_binding*/ ctx[25](null, line);

	const block = {
		c: function create() {
			button = element("button");
			h3 = element("h3");
			t = space();
			attr_dev(h3, "id", /*line*/ ctx[33].id);
			add_location(h3, file, 215, 40, 9049);
			set_style(button, "display", "block");
			set_style(button, "width", "100%");
			add_location(button, file, 214, 36, 8896);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, h3);
			h3.innerHTML = raw_value;
			assign_h3();
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(
					button,
					"click",
					function () {
						if (is_function(/*contentTable*/ ctx[6].scrollIntoView({ block: 'start' }, true))) /*contentTable*/ ctx[6].scrollIntoView({ block: 'start' }, true).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (line !== /*line*/ ctx[33]) {
				unassign_h3();
				line = /*line*/ ctx[33];
				assign_h3();
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			unassign_h3();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(214:90) ",
		ctx
	});

	return block;
}

// (206:101) 
function create_if_block_3(ctx) {
	let ol;
	let t;
	let each_value_2 = /*line*/ ctx[33].ol;
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const block = {
		c: function create() {
			ol = element("ol");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			add_location(ol, file, 206, 36, 8440);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ol, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ol, null);
			}

			append_dev(ol, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*manifesto*/ 2048) {
				each_value_2 = /*line*/ ctx[33].ol;
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ol, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ol);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(206:101) ",
		ctx
	});

	return block;
}

// (200:32) {#if typeof (line === 'object') && (Object.keys(line)[0]=="ul")}
function create_if_block_2(ctx) {
	let ul;
	let t;
	let each_value_1 = /*line*/ ctx[33].ul;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			add_location(ul, file, 200, 36, 8075);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append_dev(ul, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*manifesto*/ 2048) {
				each_value_1 = /*line*/ ctx[33].ul;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(200:32) {#if typeof (line === 'object') && (Object.keys(line)[0]==\\\"ul\\\")}",
		ctx
	});

	return block;
}

// (208:40) {#each line.ol as line2}
function create_each_block_2(ctx) {
	let li;
	let raw_value = /*line2*/ ctx[36] + "";

	const block = {
		c: function create() {
			li = element("li");
			add_location(li, file, 208, 44, 8556);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			li.innerHTML = raw_value;
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(208:40) {#each line.ol as line2}",
		ctx
	});

	return block;
}

// (202:40) {#each line.ul as line2}
function create_each_block_1(ctx) {
	let li;
	let t_value = /*line2*/ ctx[36] + "";
	let t;

	const block = {
		c: function create() {
			li = element("li");
			t = text(t_value);
			add_location(li, file, 202, 44, 8191);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(202:40) {#each line.ul as line2}",
		ctx
	});

	return block;
}

// (198:24) {#each manifesto as line}
function create_each_block(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*line*/ ctx[33] !== "") return create_if_block_1;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (if_block) if_block.p(ctx, dirty);
		},
		d: function destroy(detaching) {
			if (if_block) {
				if_block.d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(198:24) {#each manifesto as line}",
		ctx
	});

	return block;
}

// (171:16) {#key key}
function create_key_block_1(ctx) {
	let div1;
	let button;
	let t0_value = /*$content*/ ctx[10].tableOfContents + "";
	let t0;
	let t1;
	let img;
	let img_src_value;
	let t2;
	let div0;
	let t3;
	let div2;
	let mounted;
	let dispose;
	let each_value_3 = /*contentHeadings*/ ctx[12];
	validate_each_argument(each_value_3);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	let each_value = /*manifesto*/ ctx[11];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div1 = element("div");
			button = element("button");
			t0 = text(t0_value);
			t1 = space();
			img = element("img");
			t2 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t3 = space();
			div2 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			if (!src_url_equal(img.src, img_src_value = "../assets/arrow_down.svg")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "arrow down");
			set_style(img, "transform", "scaleY(-1)");
			add_location(img, file, 174, 28, 6403);
			attr_dev(button, "id", "toggle-content");
			add_location(button, file, 172, 24, 6209);
			attr_dev(div0, "class", "module");
			set_style(div0, "display", "initial");
			add_location(div0, file, 176, 24, 6572);
			attr_dev(div1, "id", "table-content");
			add_location(div1, file, 171, 20, 6134);
			attr_dev(div2, "id", "main");
			add_location(div2, file, 196, 20, 7811);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, button);
			append_dev(button, t0);
			append_dev(button, t1);
			append_dev(button, img);
			/*img_binding*/ ctx[16](img);
			/*button_binding*/ ctx[17](button);
			append_dev(div1, t2);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			/*div0_binding*/ ctx[23](div0);
			/*div1_binding*/ ctx[24](div1);
			insert_dev(target, t3, anchor);
			insert_dev(target, div2, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}

			/*div2_binding*/ ctx[27](div2);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[18], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*$content*/ 1024 && t0_value !== (t0_value = /*$content*/ ctx[10].tableOfContents + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*contentHeadings, buttons, goToChapter*/ 36880) {
				each_value_3 = /*contentHeadings*/ ctx[12];
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_3(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div0, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_3.length;
			}

			if (dirty[0] & /*manifesto, contentTable, headingsObjects*/ 2144) {
				each_value = /*manifesto*/ ctx[11];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div2, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			/*img_binding*/ ctx[16](null);
			/*button_binding*/ ctx[17](null);
			destroy_each(each_blocks_1, detaching);
			/*div0_binding*/ ctx[23](null);
			/*div1_binding*/ ctx[24](null);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(div2);
			destroy_each(each_blocks, detaching);
			/*div2_binding*/ ctx[27](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_key_block_1.name,
		type: "key",
		source: "(171:16) {#key key}",
		ctx
	});

	return block;
}

// (167:0) {#key $loaded}
function create_key_block(ctx) {
	let if_block_anchor;
	let if_block = /*$loaded*/ ctx[9] == 2 && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*$loaded*/ ctx[9] == 2) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_key_block.name,
		type: "key",
		source: "(167:0) {#key $loaded}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let previous_key = /*$loaded*/ ctx[9];
	let key_block_anchor;
	let key_block = create_key_block(ctx);

	const block = {
		c: function create() {
			key_block.c();
			key_block_anchor = empty();
			this.c = noop;
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			key_block.m(target, anchor);
			insert_dev(target, key_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*$loaded*/ 512 && safe_not_equal(previous_key, previous_key = /*$loaded*/ ctx[9])) {
				key_block.d(1);
				key_block = create_key_block(ctx);
				key_block.c();
				key_block.m(key_block_anchor.parentNode, key_block_anchor);
			} else {
				key_block.p(ctx, dirty);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(key_block_anchor);
			key_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function hideBlock(arrow, block) {
	if (block.style.display == "none" || block.style.display == "") {
		block.style.display = "initial";
		arrow.style.transform = "scaleY(-1)";
		localStorage.setItem("manifesto-hide-content", "false");
	} else {
		block.style.display = "none";
		arrow.style.transform = "";
		localStorage.setItem("manifesto-hide-content", "true");
	}
}

function instance($$self, $$props, $$invalidate) {
	let $loaded;
	let $content;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('manifesto-component', slots, []);
	let manifesto = [];
	let key;
	let contentButton;
	let contentArrow;
	let contentBlock;
	let buttons = [];
	let headingsObjects = {};
	let contentHeadings = [];
	let contentTable;
	let lastTop = 0;
	let margin = 0;
	let root;
	let main;
	let loaded = writable(0);
	validate_store(loaded, 'loaded');
	component_subscribe($$self, loaded, value => $$invalidate(9, $loaded = value));
	let content = writable({});
	validate_store(content, 'content');
	component_subscribe($$self, content, value => $$invalidate(10, $content = value));
	loadLocaleContent(content, "countries", loaded);
	let locale = loadLocaleContent(content, "manifesto-component", loaded);
	const htmlDelims = ["ul", "ol"];

	getData("/locales/" + locale + "/manifesto.txt", function (response) {
		let splitText = response.split(/\r?\n/);
		let currentChapter;
		let cnt = 0;

		for (let j = 0; j < splitText.length; j++) {
			let line = splitText[j];
			let delimInd = htmlDelims.map(x => line.includes("<" + x + ">")).findIndex(x => x);

			if (delimInd != -1) {
				let delim = htmlDelims[delimInd];
				let obj = {};
				obj[delim] = [];
				let delimEndTag = "</" + delim + ">";

				while (true) {
					j += 1;
					line = splitText[j];

					if (line.includes(delimEndTag)) {
						manifesto.push(obj);
						break;
					} else {
						obj[delim].push(line);
					}
				}
			} else {
				if (line.slice(0, 3) == "###") {
					let heading = line.slice(4, line.length);
					let id = heading.toLowerCase().trim().replaceAll(" ", "-");
					currentChapter.push({ id, name: heading, index: cnt });
					cnt += 1;

					manifesto.push({
						type: "h3",
						id,
						line: heading,
						index: cnt
					});
				} else if (line.slice(0, 2) == "##") {
					let heading = line.slice(3, line.length);
					let id = heading.toLowerCase().trim().replaceAll(" ", "-");

					contentHeadings.push({
						id: heading.toLowerCase().trim().replaceAll(" ", "-"),
						name: heading,
						index: cnt
					});

					cnt += 1;
					currentChapter = [];
					contentHeadings.push(currentChapter);

					manifesto.push({
						type: "h2",
						id,
						line: heading,
						index: cnt
					});
				} else {
					manifesto.push(line);
				}
			}
		}

		$$invalidate(0, key += 1);
	});

	function goToChapter(id) {
		headingsObjects[id].scrollIntoView({ block: 'start' }, true);
	}

	addEventListener("scroll", event => {
		if (window.innerWidth > 1080) {
			let top = px2rem(window.scrollY);
			let textBottom = px2rem(root.getBoundingClientRect().bottom + window.scrollY);
			let tableBottom = px2rem(contentTable.getBoundingClientRect().bottom + window.scrollY);

			if (top > lastTop && top < 5 || top < lastTop && top < 5) {
				margin = -Math.min(px2rem(window.scrollY), 5);
			} else if (tableBottom >= textBottom - 1.5) {
				margin = margin - (tableBottom - (textBottom - 1.5));
			} else {
				if (margin > -5) {
					margin = -5;
				}

				if (top < 5 && top != 0) {
					let dif = px2rem(contentTable.offsetHeight - window.innerHeight);
					margin = -Math.min(px2rem(window.scrollY), 5 + dif + 2.5);
				} else if (top < lastTop || margin == 0) {
					if (margin < -5) {
						margin = margin + (lastTop - top);
					} else {
						margin = -5;
					}
				} else {
					if (contentTable.offsetHeight > window.innerHeight) {
						let dif = px2rem(contentTable.offsetHeight) - px2rem(window.innerHeight);

						if (margin > -(dif + 8)) {
							margin = margin + (lastTop - top);
						} else {
							margin = -(dif + 8);
						}
					}
				}
			}

			$$invalidate(6, contentTable.style.marginTop = margin + "rem", contentTable);
			lastTop = px2rem(window.scrollY);
		} else {
			$$invalidate(6, contentTable.style.marginTop = "0rem", contentTable);
		}
	});

	onMount(() => {
		let hideBool = localStorage.getItem("manifesto-hide-content");

		if (hideBool != undefined && hideBool != null) {
			if (hideBool == "true") {
				hideBlock(contentArrow, contentBlock);
			}
		}
	});

	const writable_props = [];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<manifesto-component> was created with unknown prop '${key}'`);
	});

	function img_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			contentArrow = $$value;
			$$invalidate(2, contentArrow);
		});
	}

	function button_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			contentButton = $$value;
			$$invalidate(1, contentButton);
		});
	}

	const click_handler = () => hideBlock(contentArrow, contentBlock);

	function button_binding_1($$value, obj2) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			buttons[obj2.index] = $$value;
			$$invalidate(4, buttons);
		});
	}

	const click_handler_1 = obj2 => goToChapter(obj2.id);

	function button_binding_2($$value, obj) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			buttons[obj.index] = $$value;
			$$invalidate(4, buttons);
		});
	}

	const click_handler_2 = obj => goToChapter(obj.id);

	function div0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			contentBlock = $$value;
			$$invalidate(3, contentBlock);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			contentTable = $$value;
			$$invalidate(6, contentTable);
		});
	}

	function h3_binding($$value, line) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			headingsObjects[line.id] = $$value;
			$$invalidate(5, headingsObjects);
		});
	}

	function h2_binding($$value, line) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			headingsObjects[line.id] = $$value;
			$$invalidate(5, headingsObjects);
		});
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			main = $$value;
			$$invalidate(8, main);
		});
	}

	function div1_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			root = $$value;
			$$invalidate(7, root);
		});
	}

	$$self.$capture_state = () => ({
		onMount,
		writable,
		getData,
		px2rem,
		loadLocaleContent,
		manifesto,
		key,
		contentButton,
		contentArrow,
		contentBlock,
		buttons,
		headingsObjects,
		contentHeadings,
		contentTable,
		lastTop,
		margin,
		root,
		main,
		loaded,
		content,
		locale,
		htmlDelims,
		hideBlock,
		goToChapter,
		$loaded,
		$content
	});

	$$self.$inject_state = $$props => {
		if ('manifesto' in $$props) $$invalidate(11, manifesto = $$props.manifesto);
		if ('key' in $$props) $$invalidate(0, key = $$props.key);
		if ('contentButton' in $$props) $$invalidate(1, contentButton = $$props.contentButton);
		if ('contentArrow' in $$props) $$invalidate(2, contentArrow = $$props.contentArrow);
		if ('contentBlock' in $$props) $$invalidate(3, contentBlock = $$props.contentBlock);
		if ('buttons' in $$props) $$invalidate(4, buttons = $$props.buttons);
		if ('headingsObjects' in $$props) $$invalidate(5, headingsObjects = $$props.headingsObjects);
		if ('contentHeadings' in $$props) $$invalidate(12, contentHeadings = $$props.contentHeadings);
		if ('contentTable' in $$props) $$invalidate(6, contentTable = $$props.contentTable);
		if ('lastTop' in $$props) lastTop = $$props.lastTop;
		if ('margin' in $$props) margin = $$props.margin;
		if ('root' in $$props) $$invalidate(7, root = $$props.root);
		if ('main' in $$props) $$invalidate(8, main = $$props.main);
		if ('loaded' in $$props) $$invalidate(13, loaded = $$props.loaded);
		if ('content' in $$props) $$invalidate(14, content = $$props.content);
		if ('locale' in $$props) locale = $$props.locale;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		key,
		contentButton,
		contentArrow,
		contentBlock,
		buttons,
		headingsObjects,
		contentTable,
		root,
		main,
		$loaded,
		$content,
		manifesto,
		contentHeadings,
		loaded,
		content,
		goToChapter,
		img_binding,
		button_binding,
		click_handler,
		button_binding_1,
		click_handler_1,
		button_binding_2,
		click_handler_2,
		div0_binding,
		div1_binding,
		h3_binding,
		h2_binding,
		div2_binding,
		div1_binding_1
	];
}

class Manifesto_component extends SvelteElement {
	constructor(options) {
		super();
		this.shadowRoot.innerHTML = `<style>@import '/css/common.css';#main b{color:#d50400}#table-content{position:fixed;display:flex;flex-direction:column;border:#cdcdcd 0.1rem solid;border-radius:1rem;padding:2rem;padding-top:1rem;padding-right:0.8rem;padding-bottom:1.5rem;margin-bottom:2rem;width:20rem;height:max-content}#toggle-content{position:relative;width:100%;font-size:1.2rem;font-family:var(--sans-serif,sans-serif);text-align:left;padding-bottom:1rem;font-weight:bold;padding-top:0.3rem}#toggle-content img{position:absolute;top:0.3rem;right:0.8rem;width:1.5rem}.module{position:relative;display:inline-block;width:100%;height:max-content;padding-right:1.2rem}.heading-button-wrapper{position:relative}.heading-button{color:black;height:auto;width:100%;padding-top:0.25rem;padding-bottom:0.35rem;text-align:left;font-family:var(--sans-serif,sans-serif);font-size:1.2rem}.level0{position:relative;padding-left:0.5rem;z-index:1}.level1{position:relative;padding-left:1.5rem;z-index:1;margin-left:1rem;width:calc(100% - 1rem);border-left:#cdcdcd 0.1rem solid}.heading-button:hover{background-color:hsla(344, 73%, 57%, 0.12)}.heading-button:active{background-color:hsla(344, 73%, 57%, 0.5)}h1{margin-bottom:1rem;font-size:2rem;text-align:center}h2{margin-bottom:1rem;text-align:center}h3{margin-bottom:1rem}#text-container{position:relative;display:grid;grid-template-columns:20rem 700px 20rem;grid-gap:2rem;max-width:calc(100vw - 4rem);margin:auto}#container{display:flex;align-content:center;margin:auto;max-width:min(1800px,100vw);margin-top:1rem;margin-bottom:4rem}#main{grid-column:2}#main>p{margin-bottom:1rem}#container p{text-align:justify}@media only screen and (max-width: 1210px){#text-container{position:relative;display:grid;grid-template-columns:auto;grid-gap:2rem;max-width:calc(1800px,100vw - 4rem);margin:auto}#toggle-content img{right:0}#table-content{position:relative;border:#a9a9a9 0.1rem solid;border-radius:1rem;padding:2rem;padding-bottom:1.5rem;margin-bottom:2rem;height:max-content;width:100%}.module{padding-right:0}#main{grid-column:1}#container{max-width:min(700px,100vw)}}</style>`;

		init(
			this,
			{
				target: this.shadowRoot,
				props: attribute_to_object(this.attributes),
				customElement: true
			},
			instance,
			create_fragment,
			safe_not_equal,
			{},
			null,
			[-1, -1]
		);

		if (options) {
			if (options.target) {
				insert_dev(options.target, this, options.anchor);
			}
		}
	}
}

customElements.define("manifesto-component", Manifesto_component);

export { Manifesto_component as default };
